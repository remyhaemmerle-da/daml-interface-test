module Wallet where

import Note

type WalletId = ContractId Wallet

interface Wallet where
  getOwner: Party

  credit_: NoteId -> Update WalletId
  withdraw_: Party -> Int -> Update (WalletId, NoteId)

  choice Credit: WalletId
    with
      from: Party
      noteId: NoteId
    controller from
    do
      proposalId <- exercise noteId NoteTransfer with newOwner = getOwner this
      newNoteId <- exercise proposalId NoteAccept
      -- authorization is leak toward some untrusted code
      credit_ this newNoteId
      -- We can circonvent this leaking issue by limited the authorization through an internal call
      -- comment the statement above and uncomment the one below to fix the issue.
      -- exercise self CreditInternal with noteId = newNoteId

  choice CreditInternal: WalletId
    with
      noteId: NoteId
    controller getOwner this
    do
      credit_ this noteId

  choice Withdraw: (WalletId, NoteId)
    with
      issuer: Party
      amount: Int
    controller getOwner this
    do
      withdraw_ this issuer amount

  nonconsuming choice Transfer: (WalletId, WalletId)
    with
      from: Party
      to: WalletId
      issuer: Party
      amount: Int
    controller from
    do
      (newWalltet, noteId) <- exercise self Withdraw with
        issuer = issuer, amount = amount
      updateToWallet <- exercise to Credit with
        from = from, noteId = noteId
      pure (newWalltet, updateToWallet)
